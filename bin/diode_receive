#!/usr/bin/env python3
"""
Receive files through unidirectional serial device
"""
# pylint: disable=W0603


import os
import sys
import base64
import hashlib
import argparse
import time
import re
import logging
import logging.handlers
from subprocess import Popen
import serial

DIODE_LOGGER = logging.getLogger('DIODE')
DIODE_LOGGER.setLevel(logging.INFO)
SYSLOG_FORMATTER = logging.Formatter('%(name)s %(levelname)s: %(message)s')
STDERR_FORMATTER = logging.Formatter('%(asctime)s %(levelname)s: %(message)s')
SYSLOG_HANDLER = logging.handlers.SysLogHandler(address='/dev/log')
SYSLOG_HANDLER.setFormatter(SYSLOG_FORMATTER)
STDERR_HANDLER = logging.StreamHandler(sys.stderr)
STDERR_HANDLER.setLevel(logging.DEBUG)
STDERR_HANDLER.setFormatter(STDERR_FORMATTER)
DIODE_LOGGER.addHandler(SYSLOG_HANDLER)
DIODE_LOGGER.addHandler(STDERR_HANDLER)

PARSER = argparse.ArgumentParser(description='Serial device options')
PARSER.add_argument('--speed', type=int, nargs='?', default=115200,
                    help='serial bit rate, default 115200')
PARSER.add_argument('--device', type=str, nargs='?', required=True,
                    help='serial device, i.e. /dev/cuaU0')
PARSER.add_argument('--arduino', type=str, nargs='?', required=False,
                    help='serial device, i.e. /dev/cuaU1')
PARSER.add_argument('--directory', type=str, nargs='?', required=True,
                    help='directory from which to send files')

ARGS = PARSER.parse_args()
TOTAL_DATA = 0
FILES_TOTAL = 0
FILES_ERROR = 0
FILE_SIZE = 0
TRANSFERRED_DATA = 0
FILENAME = None
LAST_FILENAME = None

ARDUINO = serial.Serial(ARGS.arduino, 38400, timeout=1)

def send_status(state_id):
    """
    Send info to Arduino to update LCD
    """
    if ARGS.arduino:
        if state_id == 1:
            state = "Rx   "
            progress = int((TRANSFERRED_DATA / FILE_SIZE)*100)
        else:
            state = "Wait "
        data_kb = int(TOTAL_DATA/1024)
        line1 = (state + str(FILES_TOTAL)+"F " + str(FILES_ERROR)+"E")
        line2 = (str(data_kb) + "KB" + (" " + str(progress) + "%" if
                                        state_id == 1 else ""))
        ARDUINO.write(bytes(line1+'\n', 'ascii'))
        ARDUINO.write(bytes(line2+'\n', 'ascii'))

def reset(success):
    """
    reset status variables
    """
    global CONTENT
    CONTENT = None
    global FILENAME
    global LAST_FILENAME
    LAST_FILENAME = FILENAME
    FILENAME = None
    global FILENAME_B64
    FILENAME_B64 = None
    global HASHSUM
    HASHSUM = None
    global HASHSUM_RECEIVED
    HASHSUM_RECEIVED = None
    global M
    M = hashlib.md5()
    global STARTED
    STARTED = False
    global FILE_SIZE
    FILE_SIZE = 0
    global TRANSFERRED_DATA
    TRANSFERRED_DATA = 0
    global FILES_TOTAL
    FILES_TOTAL = FILES_TOTAL + 1
    if not success:
        global FILES_ERROR
        FILES_ERROR = FILES_ERROR + 1
    global ARDUINO
    ARDUINO.write(bytes('               \n', 'ascii'))
    ARDUINO.write(bytes('               \n', 'ascii'))

with serial.Serial(ARGS.device, ARGS.speed, timeout=1) as ser:
    M = hashlib.md5()
    STARTED = False
    time.sleep(3)
    send_status(0)
    while True:
        LINE = ser.readline().strip().decode('ascii')
        if LINE == chr(1): # SOH - Start Of Header
            STARTED = True
            FILENAME_B64, FILE_SIZE = ser.readline().strip().split(b" ")
            FILE_SIZE = int(FILE_SIZE)
            FILENAME = base64.b64decode(FILENAME_B64).decode('ascii')
            M.update(FILENAME_B64)
            DIODE_LOGGER.info("Receiving file %s", FILENAME)
        elif (STARTED and LINE == chr(2)): # STX - Start of Text
            DIODE_LOGGER.info("Buffering content.")
            send_status(1)
            CONTENT = b''
            N = 0
            while True:
                LINE = ser.readline().strip()
                if LINE == bytes(chr(3), 'ascii'): # ETX - End of Text:
                    HASHSUM = ser.readline().strip()
                    break
                else:
                    N = N + 1
                    M.update(LINE)
                    try:
                        LINE_DECODED = base64.b64decode(LINE)
                    except base64.binascii.Error:
                        DIODE_LOGGER.error("Cannot decode Base64.")
                        reset(False)
                        break
                    CONTENT += LINE_DECODED
                    TRANSFERRED_DATA = TRANSFERRED_DATA + len(LINE_DECODED)
                    TOTAL_DATA = TOTAL_DATA + len(LINE_DECODED)
                    send_status(1)
        elif(STARTED and LINE == chr(4)): # EOT - End of Transmission
            HASHSUM_RECEIVED = M.hexdigest().encode("ascii", "ignore")
            if HASHSUM_RECEIVED == HASHSUM:
                FILEPATH = os.path.join(ARGS.directory, FILENAME)
                if os.path.dirname(FILEPATH) and not os.path.exists(os.path.dirname(FILEPATH)):
                    os.makedirs(os.path.dirname(FILEPATH))
                DIODE_LOGGER.info("Hashsums match, writing to %s", FILEPATH)
                F = open(FILEPATH, "wb")
                F.write(CONTENT)
                F.close()
                reset(True)
            else:
                DIODE_LOGGER.error("Hashsums do not match.")
                reset(False)
            send_status(0)
        elif LINE == chr(25):
            CHUNKS_GLOBBER = re.search("(.*-part_)[a-z]{2}", LAST_FILENAME).group(1)
            ORIG_NAME = re.search("(.*)-part_[a-z]{2}", LAST_FILENAME).group(1)
            DIODE_LOGGER.info("Assembling previously transmitted cunks to %s", ORIG_NAME)
            CMD = "/bin/cat {}* > {}".format(CHUNKS_GLOBBER, ORIG_NAME)
            Popen(CMD, shell=True, executable='/bin/ksh', cwd=ARGS.directory)
        else:
            send_status(0)
            time.sleep(0.1)
